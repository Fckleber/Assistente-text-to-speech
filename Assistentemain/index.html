<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assistente de texto| Text-to-Speech</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js"></script>
    <style>
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fc;
        }
        
        .tts-container {
            max-width: 800px;
            width: 95%;
            margin-top: 2rem;
            margin-bottom: 2rem;
            padding: 1.5rem;
        }
        
        .text-area-style {
            transition: all 0.15s ease-in-out;
            min-height: 150px;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen">

    <div class="tts-container rounded-xl bg-white shadow-xl">
        <h1 class="text-3xl font-extrabold text-gray-900 mb-2">Assistente de texto</h1>
        <!-- Área de Input de Texto (visível para edição) -->
        <textarea
            id="textInput"
            class="w-full p-4 border-2 border-indigo-200 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 resize-y text-area-style"
            placeholder="Exemplo: 'Naquela noite escura e tempestuosa, o velho farol acendeu sua luz pela milésima vez, guiando os navios perdidos para a segurança...'"
            maxlength="15000"
        ></textarea>
        
        <div 
            id="highlightedDisplay" 
            class="w-full p-4 border-2 border-indigo-200 rounded-lg overflow-y-auto text-gray-800 text-area-style hidden" 
            style="white-space: pre-wrap;"
        ></div>
        
        <p class="text-sm text-gray-500 mt-1 text-right" id="charCount">0/15000 caracteres</p>
        <label for="fileInput" class="w-full mt-4 py-2 px-6 bg-gray-600 text-white font-bold text-lg rounded-xl hover:bg-gray-700 transition duration-200 ease-in-out focus:outline-none focus:ring-4 focus:ring-gray-500 focus:ring-opacity-50 flex items-center justify-center cursor-pointer">
            Carregar PDF
        </label>
        <input type="file" id="fileInput" accept="application/pdf" class="hidden">

        <button
            id="speakButton"
            class="w-full mt-4 py-3 px-6 bg-indigo-600 text-white font-bold text-lg rounded-xl hover:bg-indigo-700 transition duration-200 ease-in-out focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50 disabled:bg-indigo-400 flex items-center justify-center"
            onclick="generateSpeech()"
        >
            <span id="buttonText">Falar Texto</span>
            <svg id="loadingSpinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
        </button>

     
        <div id="statusMessage" class="mt-4 p-3 rounded-lg text-sm hidden" role="alert"></div>

        <p class="text-xs text-gray-500 mt-6 text-center">
            O áudio é gerado em tempo real.
        </p>
    </div>

   <script>
        //Referências DOM
        const textInput = document.getElementById('textInput');
        const speakButton = document.getElementById('speakButton');
        const buttonText = document.getElementById('buttonText');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const statusMessage = document.getElementById('statusMessage');
        const charCount = document.getElementById('charCount');
        const highlightedDisplay = document.getElementById('highlightedDisplay');
        const fileInput = document.getElementById('fileInput');

        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        let isSpeaking = false;
        
        const utterance = new SpeechSynthesisUtterance();

        textInput.addEventListener('input', () => {
            const currentLength = textInput.value.length;
            charCount.textContent = `${currentLength}/15000 caracteres`;
        });

  
        const syncHeight = () => {
             const height = textInput.offsetHeight;
             highlightedDisplay.style.height = height > 150 ? height + 'px' : '150px';
        };
        textInput.addEventListener('change', syncHeight);
        textInput.addEventListener('keyup', syncHeight);
        textInput.addEventListener('focus', syncHeight);
        window.addEventListener('resize', syncHeight);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.classList.remove('hidden', 'bg-red-100', 'text-red-700', 'bg-green-100', 'text-green-700', 'bg-blue-100', 'text-blue-700');
            if (isError) {
                statusMessage.classList.add('bg-red-100', 'text-red-700');
            } else if (message.includes("Sucesso") || message.includes("concluída")) {
                statusMessage.classList.add('bg-green-100', 'text-green-700');
            } else {
                statusMessage.classList.add('bg-blue-100', 'text-blue-700');
            }
        }

        //Função de Geração de Fala

        function setupVoice() {
            let voices = window.speechSynthesis.getVoices();
            if (voices.length === 0) {
                window.speechSynthesis.onvoiceschanged = () => {
                    voices = window.speechSynthesis.getVoices();
                    const ptBRVoice = voices.find(voice => voice.lang === 'pt-BR');
                    if (ptBRVoice) {
                        utterance.voice = ptBRVoice;
                    }
                    utterance.lang = 'pt-BR'; 
                    utterance.rate = 1.0; 
                };
            } else {
                const ptBRVoice = voices.find(voice => voice.lang === 'pt-BR');
                if (ptBRVoice) {
                    utterance.voice = ptBRVoice;
                }
                utterance.lang = 'pt-BR';
                utterance.rate = 1.0;
            }
        }
        async function handlePdfUpload(event) {
            const file = event.target.files[0];
            if (!file || file.type !== 'application/pdf') {
                updateStatus("Por favor, selecione um arquivo PDF.", true);
                return;
            }

            updateStatus("Lendo PDF...", false);
            speakButton.disabled = true; 

            try {
                const reader = new FileReader();
                
                reader.onload = async (e) => {
                    const typedArray = new Uint8Array(e.target.result);
                    const pdfDoc = await pdfjsLib.getDocument({ data: typedArray }).promise;
                    
                    let fullText = '';
                    
                    for (let i = 1; i <= pdfDoc.numPages; i++) {
                        const page = await pdfDoc.getPage(i);
                        const textContent = await page.getTextContent();
                        
                        
                        const pageText = textContent.items.map(item => item.str).join(' ');
                        fullText += pageText + '\n\n';               }
                    
                    textInput.value = fullText.trim();
                    updateStatus("PDF carregado com sucesso!", false);

                    textInput.dispatchEvent(new Event('input', { bubbles: true }));
                    syncHeight();
                };
                
                reader.readAsArrayBuffer(file);

            } catch (error) {
                console.error("Erro ao ler o PDF:", error);
                updateStatus(`Erro ao processar o PDF: ${error.message}`, true);
            } finally {
                speakButton.disabled = false; 
                event.target.value = null; 
            }
        }

        fileInput.addEventListener('change', handlePdfUpload);
        async function generateSpeech() {
            if (isSpeaking) {
                window.speechSynthesis.cancel();
                return;
            }

            const userText = textInput.value;
            if (!userText.trim()) {
                updateStatus("Por favor, digite um texto para narrar.", true);
                return;
            }

            //Lógica de Seleção
            let textToNarrate = userText.trim();
            let originalStartIndex = 0;
            const selectionStart = textInput.selectionStart;
            const selectionEnd = textInput.selectionEnd;

            if (selectionStart !== selectionEnd) {
                textToNarrate = userText.substring(selectionStart, selectionEnd);
                originalStartIndex = selectionStart;
            }
            //fim Lógica de Seleção

            // UI Loading State
            speakButton.disabled = true;
            textInput.classList.add('hidden');
            highlightedDisplay.classList.remove('hidden');
            highlightedDisplay.textContent = userText; 
            buttonText.textContent = "Parar Narração"; 
            loadingSpinner.classList.remove('hidden');
            statusMessage.classList.add('hidden');
            
            isSpeaking = true;
            speakButton.disabled = false;
            utterance.text = textToNarrate;
//range das palavras
            utterance.onboundary = (event) => {
                if (event.name === 'word') {
                    const charIndex = event.charIndex;
                    const charLength = event.charLength; 

                    if (charIndex === undefined || charLength === undefined) return;

                    // Calcula o início e fim no texto completo
                    const startInFullText = originalStartIndex + charIndex;
                    const endInFullText = startInFullText + charLength;
                    
                    const before = userText.substring(0, startInFullText);
                    const current = userText.substring(startInFullText, endInFullText);
                    const after = userText.substring(endInFullText);

                    highlightedDisplay.innerHTML = 
                        `<span>${before}</span>` +
                        `<span id="currentChunk" class="bg-yellow-200 font-bold p-0.5 rounded">${current}</span>` +
                        `<span>${after}</span>`;
                    
                    const currentChunkElement = document.getElementById('currentChunk');
                    if (currentChunkElement) {
                        currentChunkElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            };

            //Evento de Fim de Fala (Limpeza)
            const resetUI = () => {
                isSpeaking = false;
                speakButton.disabled = false;
                textInput.classList.remove('hidden');
                highlightedDisplay.classList.add('hidden');
                buttonText.textContent = "Falar Texto";
                loadingSpinner.classList.add('hidden');
                highlightedDisplay.innerHTML = userText; // Limpa destaque
            };

            utterance.onend = () => {
                resetUI();
                updateStatus("Narração concluída com Sucesso!", false);
            };

            utterance.onerror = (event) => {
                resetUI();
                console.error("Erro na SpeechSynthesis:", event);
                updateStatus(`Erro na narração: ${event.error}`, true);
            };

            // Inicia a fala
            window.speechSynthesis.speak(utterance);
        }

        // Inicializa a contagem, altura e vozes ao carregar
        window.onload = () => {
             const currentLength = textInput.value.length;
             charCount.textContent = `${currentLength}/15000 caracteres`;
             syncHeight();
             highlightedDisplay.textContent = textInput.value;
             // Chama a função para pré-carregar as vozes
             setupVoice();
        };

        // Garante que o setup de voz seja chamado se as vozes mudarem
        if (window.speechSynthesis.onvoiceschanged !== undefined) {
            window.speechSynthesis.onvoiceschanged = setupVoice;
        }
    </script>
</body>
</html>
